<html>

<head>
    <title>Torus</title>


    <style>
        body {
            margin: 0;
            overflow: hidden;
        };
        canvas  {
          width: 100%;
          height: 100%;
        };
    </style>

</head>

<body>
  <script src="js/three.js"></script>
  <script src="js/OrbitControls.js"></script>
  <!-- <script src="js/jquery-1.9.0.js"></script> -->
  <script src="js/Stats.js"></script>
  <script src="js/dat.gui.min.js"></script>

<script>

init();
animate();

//test

var stats = InitStats();

function init() {

  scene = new THREE.Scene();

	camera = new THREE.PerspectiveCamera( 200, window.innerWidth / window.innerHeight, 0.01, 1000 );
  camera.position.x = -30;
       camera.position.y = 40;
       camera.position.z = 50;
       camera.lookAt(new THREE.Vector3(10, 0, 0));

  controls = new THREE.OrbitControls( camera );
  controls.update();


  window.addEventListener ( 'resize', function( )
  {
    var width = window.innerWidth;
    var height = window.innerHeight;
    renderer.setSize( width, height );
    camera.aspect = width / height;
    camera.updateProjectionMatrix ( );
  } );

	geometry = new THREE.TorusGeometry( 10, 10 );
	material = new THREE.MeshNormalMaterial();
  material = new THREE.MeshNormalMaterial( { color: 0xF00FFF, wireframe: true} );

	mesh = new THREE.Mesh( geometry, material );
	scene.add( mesh );

  light = new THREE.AmbientLight( 0x404040 ); // soft white light
  scene.add( light );


	renderer = new THREE.WebGLRenderer( { antialias: true } );
  // renderer.setClearColor(new THREE.Color(0xF00FFF, 1.0));
	renderer.setSize( window.innerWidth, window.innerHeight );
  renderer.shadowMapEnabled = true;
	document.body.appendChild( renderer.domElement );
  var step = 0;
}

   var controls = new function () {
     this.radius = torus.children[0].geometry.radius;
           this.tube = torus.children[0].geometry.tube;
           this.radialSegments = torus.children[0].geometry.radialSegments;
           this.tubularSegments = torus.children[10].geometry.tubularSegments;
           this.arc = torus.children[0].geometry.arc;
           this.redraw = function () {
               // remove the old plane
               scene.remove(torus);
               // create a new one
               torus = createMesh(new THREE.TorusGeometry(controls.radius, controls.tube, Math.round(controls.radialSegments), Math.round(controls.tubularSegments), controls.arc));
               scene.add(torus);
           };
       }

       (function () {

	'use strict';

	var parameters = {
		radius: 10,
		tube: 1,
		tubularSegments: 20,
		radialSegments: 10,
		p: 3,
		q: 2
	};

	var geometries;

	QUnit.module( "Extras - Geometries - TorusKnotGeometry", {

		beforeEach: function() {

			geometries = [

				new THREE.TorusKnotGeometry(),
				new THREE.TorusKnotGeometry( parameters.radius ),
				new THREE.TorusKnotGeometry( parameters.radius, parameters.tube ),
				new THREE.TorusKnotGeometry( parameters.radius, parameters.tube, parameters.tubularSegments ),
				new THREE.TorusKnotGeometry( parameters.radius, parameters.tube, parameters.tubularSegments, parameters.radialSegments ),
				new THREE.TorusKnotGeometry( parameters.radius, parameters.tube, parameters.tubularSegments, parameters.radialSegments, parameters.p, parameters.q ),

			];

		}

	});

	QUnit.test( "standard geometry tests", function( assert ) {

		runStdGeometryTests( assert, geometries );

	});

})();

      //  var gui = new dat.GUI();
      // gui.add(controls, 'radius', 0, 80).onChange(controls.redraw);
      // gui.add(controls, 'tube', 0, 40).onChange(controls.redraw);
      // gui.add(controls, 'radialSegments', 0, 40).onChange(controls.redraw);
      // gui.add(controls, 'tubularSegments', 1, 20).onChange(controls.redraw);
      // gui.add(controls, 'arc', 0, Math.PI * 2).onChange(controls.redraw);
      // render();

      function createMesh(geom) {
        // assign two materials
        var meshMaterial = new THREE.MeshNormalMaterial();
        meshMaterial.side = THREE.DoubleSide;
        var wireFrameMat = new THREE.MeshBasicMaterial();
        wireFrameMat.wireframe = true;
        // create a multimaterial
        var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial, wireFrameMat]);
        return mesh;
    }


function animate() {

	requestAnimationFrame( animate );

	mesh.rotation.x += 0.005;
	mesh.rotation.y += 0.001;

	renderer.render( scene, camera );

};


</script>
</body>
</html>
